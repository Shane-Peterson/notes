# JS 函数的执行时机

![opportunity](images/time.jpg)

## 为什么以下代码会打印 6 个 6

```JavaScript
let i = 0
for(i = 0; i < 6; i++) {
    setTimeout(() => {
        console.log(i)
    }, 0)
}
```

首先只有当循环执行完，才会执行定时器的代码。当循环执行完，`i` 为 6，所以执行 `setTimeout` 中的代码时打印6 个 6。(上面的代码中所有循环迭代只有一个共享绑定，也就是说每个 `setTimeout` 回调中的 `i` 表示相同的变量，关于定时器要记住的最重要的事情是，指定的时间间隔表示何时将定时器的代码添加到队列，而不是何时实际执行代码）。

## 如何使上面代码不打印 6 个 6

第一种方法：

```JavaScript
for(let i = 0; i < 6; i++) {
    setTimeout(() => {
        console.log(i);
    }, 0);
};
```

为什么以上代码可以打印 6 个 6？因为 `for` 循环头部的 `let` 不仅将 `i` 绑定到了 `for` 循环的块中，事实上它将其重新绑定到了每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值，也就是说每个 `setTimeout` 回调中的 `i` 表示不同的变量。

另一种方法：

```JavaScript
for (var i = 0; i < 6; i++) {
    ((i) => {
        setTimeout(() => {
            console.log(i);
        }, 0)
    })(i);
};
```

在迭代内使用立即执行函数表达式（IIFE）为每个迭代都生成一个新的作用域，使得 `setTimeout` 的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。